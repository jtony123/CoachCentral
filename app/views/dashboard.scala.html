@import tags._
@(user : models.User, active: String, player: models.Player, playerIndex: Integer, players: List[models.Player], category:String, categories: List[models.Category])





@main(title = "CoachCentral") {
    
    <div class="container-fluid" id="outer_container" style="background-color: #FBFBFB">
    @navigationbar(user: models.User, active: String)
<style> 

body {
	font:12px Arial;
}


.chart_centre {
	
}

path {
/* 	stroke: steelblue; */

	/* the width of the plotted line */
	/* stroke-width: 0.1; */

	fill: lightblue;
}



.area {
/* 	fill : lightblue; */
/* 	stroke-width: 0; */
}

.flag {
/*   fill: red; */
/*   stroke: red; */
/*   fill-opacity: 0.5; */
}


.axis path, 
.axis line {
	fill: none;
	stroke: grey;
	stroke-width: 0;
	shape-rendering: crispEdges;
}

/* the styling of the grid lines on the graph */
.grid .tick {
    stroke: lightgrey;
    stroke-opacity: 0.7;
    shape-rendering: crispEdges;
}
.grid path {
   	stroke-width: 0;
}

.legend {
	font-size: 16px;         
	font-weight: bold;         
	text-anchor: start;
	stroke-width: 2;
	shape-rendering: crispEdges;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

div.tooltip {   
  position: absolute;           
  text-align: center;           
  width: 150px;                  
  height: 120px;                 
  padding: 2px;             
  font: 12px sans-serif;     
   border: 1px; 
   border-style: solid;      
   border-radius: 12px;           
  pointer-events: none;         
}

div.acutetooltip {   
  position: absolute;           
  text-align: center;           
  width: 150px;                  
  height: 20px;                 
  padding: 2px;             
  font: 12px sans-serif;     
   border: 1px; 
   border-style: solid;      
   border-radius: 12px;           
  pointer-events: none;         
}

div.datatip {   
position: absolute;        
  text-align: left;    
  background-color: #778899;       
  width: auto;                  
  height: auto;                 
  padding: 5px;             
  font: 12px sans-serif;     
   border: 1px; 
   border-style: solid;      
   border-radius: 12px;           
  pointer-events: auto;
   
}

div.notestip {   
position: absolute;        
  text-align: left;    
  background-color: #778899;       
  width: auto;                  
  height: auto;                 
  padding: 5px;             
  font: 12px sans-serif;     
   border: 1px; 
   border-style: solid;      
   border-radius: 12px;           
  pointer-events: auto;
   
}


th, td {
    padding: 2px;
}

.cell {
	color: red;
}

#datatiptable tr:nth-child(even){
	max-width: 100%;
    background-color: #F0F8FF;
}
#datatiptable tr:nth-child(odd){
	max-width: 100%;
    background-color: #FFFFFF;
}


div.notestip {   
position: absolute;        
  text-align: left;    
  background-color: #778899;       
  width: auto;                  
  height: auto;                 
  padding: 5px;             
  font: 12px sans-serif;     
   border: 1px; 
   border-style: solid;      
   border-radius: 12px;           
  pointer-events: auto;
   
}

#notestiptable tr:nth-child(even){
	max-width: 100%;
    background-color: #F0F8FF;
}
#notestiptable tr:nth-child(odd){
	max-width: 100%;
    background-color: #EEEEEE;
}

#player_icon {
  position: relative;
  perspective: 1000;
}

#player_icon_card {
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  
   -webkit-animation-name: player_icon_flip; /* Chrome, Safari, Opera */
    -webkit-animation-duration: 2s; /* Chrome, Safari, Opera */
    animation-name: player_icon_flip;
    animation-duration: 12s;
     animation-delay: 2s;
/*      animation-direction: alternate; */
    animation-iteration-count: 2;
  
}

@@-webkit-keyframes player_icon_flip {

	10% { transform: rotateY(180deg);}
	20% { transform: rotateY(0deg);}
	60% { transform: rotateY(0deg);}
	70% { transform: rotateY(180deg);}
	80% { transform: rotateY(0deg);}
}

#player_icon:hover #player_icon_card {
-webkit-animation: none;
  transform: rotateY(180deg);
  box-shadow: -5px 5px 5px #aaa;
}

.face {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}
.face.back {
  display: block;
  transform: rotateY(180deg);
  box-sizing: border-box;
  color: red;
  text-align: center;
  background-color: #aaa;
}



</style>


<div class="container-fluid" id="groupings_toggle_buttons">
	<div>
	@for(c <- categories) {
		@if(c.name.equals(category)){
		<a href="@routes.Application.dashboard(player.playernumber, c.name)" class="badge active" style="background-color: white;"><span class="badge" style=" color: #337ab7; background-color:yellow;">@c.name</span></a>
		} else {
		<a href="@routes.Application.dashboard(player.playernumber, c.name)" class="badge" style="background-color: white;"><span class="badge" style=" color: #337ab7; background-color: white;">@c.name</span></a>
   		}
	}
	</div>
</div>




<div class="row" id ="player_carousel">
	  <div class="col-xs-5 col-sm-5 col-md-5 col-lg-5"><p class="text-center">
	  
	  <div class="btn-group btn-group-justified">
	  
	   @if(players.size() > 5){
	   
	   <a href='@routes.Application.dashboard(players.get(Math.floorMod((playerIndex - 4), players.size())).playernumber, category)' class="btn btn-default"  class="thumbnail" style="margin-bottom: 0px; border:none;">
						<div >
					
						</div>
						<div class="text-nowrap" style="text-align: center;">
							<<
						</div>
					</a>
	   }
	   
	  
	  @if(players.size() > 5){
	  
	  		@player_icon(players.get(Math.floorMod((playerIndex - 3), players.size())), category, active)
	  		
	  }
	  
	  @if(players.size() > 3){
	  		@player_icon(players.get(Math.floorMod((playerIndex - 2), players.size())), category, active)
	  }
	  
	  @if(players.size() > 1){
	  		@player_icon(players.get(Math.floorMod((playerIndex - 1), players.size())), category, active)
	  }
	
	  </div>
	  </div>
	  
	  
	  
	  <div class="col-xs-2 col-sm-2 col-md-2 col-lg-2" id="player_icon">
	  	<div id="player_icon_card">
	  		<div class="front face">
	  		
	  			<h4 style="margin-bottom: 5px; margin-top:5px;">
	  			
					<a href="@routes.Application.record(player.playernumber, category)" class="thumbnail" style="margin-bottom: 0px;">
						<div>
						
						@if(player.playerPhoto != null){
							<img class="img-responsive" src="@routes.Application.playerPhoto(player.id)" alt="" style="margin: 0 auto; max-width:150px;height:150px"/>
						} else {
							<img class="img-responsive" src='@routes.Assets.at("images/player-headshot.png")' alt=${player.playername} style="margin: 0 auto; max-width:150px;height:150px;"/>
						}
						
						</div>
						<div class="text-nowrap" style="text-align: center;">
							@player.playername
						</div>
					</a>
				</h4>
			</div> <!-- end front face -->
			
			<div class="back face">
				<h4 style="margin-bottom: 5px; margin-top:5px;">
	  			
					<a href="@routes.Application.record(player.playernumber, category)" class="thumbnail" style="margin-bottom: 0px;">
						
						<div style="margin: 0 auto; max-width:150px;height:150px;">
						alerts go here<br>
						alert 1<br>
						alert 2<br>
						<a href="@routes.Application.record(player.playernumber, category)" class="btn btn-info btn-lg">
          				<span class="glyphicon glyphicon-plus"></span> Add data
        				</a>
						
						</div>
						
						<div class="text-nowrap" style="text-align: center;">
							@player.playername
							
						</div>
						
					</a>
				</h4>
			</div>
			</div>
	  </div>
	  
	  
	  <div class="col-xs-5 col-sm-5 col-md-5 col-lg-5"><p class="text-center"></p>
	 
	 	<div class="btn-group btn-group-justified">
	 		
	 @if(players.size() > 2){
	 	@player_icon(players.get(Math.floorMod((playerIndex + 1), players.size())), category, active)
	 }
	 
	  @if(players.size() > 4){
	  	@player_icon(players.get(Math.floorMod((playerIndex + 2), players.size())), category, active)
	 }
	 
	  @if(players.size() > 6){
	  	@player_icon(players.get(Math.floorMod((playerIndex + 3), players.size())), category, active)
	 }
	 
	  @if(players.size() > 6){
	 		<a href='@routes.Application.dashboard(players.get(Math.floorMod((playerIndex + 4), players.size())).playernumber, category)' class="btn btn-default" class="thumbnail" style="margin-bottom: 0px;  border:none;">
					
			<div class="text-nowrap" style="text-align: center;">
				>>
				
			</div>		
			</a>
	 }

	 	</div>
	 	
	  </div>
	  
	  
</div><!-- end div player carousel -->




<!-- the panel below the pagination carousel -->
	
<div class="chart" class="container-fluid" id="main_chart"  style="border:1px solid #cecece; border-radius: 20px;
																	margin:20px;
																	background-color: white;
																	box-shadow: 0px 0px 10px grey;">
	<div class="chart_upper" class="row" id="chart_upper" >
	
	</div>
	<div class="chart_centre" class="row" id="chart_centre">
	
	</div>
	<div class="chart_lower" class="row" id="chart_lower">
		
	</div>

</div>
</div><!-- end  outer container-->

<script>


var acutechronic_button_border_colour = "red";
var sessionloads_button_border_colour = "#3399CC";

var sessionloads_chart_colour = "#3399CC";

var acutechronic_button_text = "ACUTE CHRONIC";
var sessionloads_button_text = "SESSION LOADS";



var acuteloadupperthreshold = 1.5,
	acuteloadlowerthreshold = 0.8;


var windowHeight = window.innerHeight|| e.clientHeight|| g.clientHeight;

// set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 25, left: 20};

var width = parseInt(d3.select('#main_chart').style('width'), 10);
	

var	navbarh = windowHeight/16,
	toggle1_h = windowHeight/16,
	carousel_h = windowHeight/8,
	toggle2_h = Math.max(((windowHeight/32)), 50)
	chart_h = Math.max(((windowHeight/2)), 400),
	toggle3_h = Math.max(((windowHeight/32)), 50);
	

var parseDate = d3.time.format("%d/%m/%Y%H%M").parse;

// set the ranges
var xScale = d3.time.scale().range([0, width]);
var y = d3.scale.linear().range([(chart_h-margin.bottom), 0]);
var y1 = d3.scale.linear().range([(chart_h-margin.bottom), 0]);
var y2 = d3.scale.linear().range([(chart_h-margin.bottom), 0]);


// define the axes
var xAxis = d3.svg.axis().scale(xScale)
	.orient("bottom").ticks(8).tickFormat(d3.time.format("%b-%d %H:%M"));
	
var yAxis = d3.svg.axis().scale(y)
	.orient("right").ticks(5);
	
	
var acuteline = d3.svg.line()
//cannot interpolate the acute line, the flags along the line cannot be interpolated
	//.interpolate("basis")
	//.defined(function(d) {return d.T_PLAYER_LOAD != "0"; })
	.x(function(d) { return xScale(d.SESS_START); })
	.y(function(d) { return y2(d.ACUTE); });
	
	
var chronicloadarea = d3.svg.area()
	.interpolate("basis")
	.x(function(d) { return xScale(d.SESS_START); })
	.y0(chart_h)
	.y1(function(d) { return y2(d.CHRONIC); });
	
	
 
 // Bookmark1
 var uppersvg = d3.select('#chart_upper').classed('chart_upper', true)
 	.append("svg").attr("id", "uppersvg").attr("width", width).attr("height", toggle2_h)
 	.append("g")
 	// transform the y coordinate by 5 to push buttons away from top edge of container
 	.attr("transform", "translate(" + margin.left + ", " + 5 + ")");
 
 
// Adds the svg canvas
var svg = d3.select('#chart_centre').classed('chart_centre', true)
	.append("svg").attr("id", "outersvg").attr("width", width).attr("height", chart_h);
 		
	svg.append("g").attr("transform", "translate(" + margin.left + ", " + 0 + ")")
		.append("rect").attr("width", width - (margin.left + margin.right))
	 	.attr("height", chart_h).attr("rx", 20).attr("ry", 20)
		.attr("id", "background_shading").attr("stroke", "#FAFAFA").attr("stroke-width", 2)
		.style("fill", "#FBFBFB");
	
// the innersvg prevents data being plotted outside the graph area - same as clipping rect
var innersvg = svg.select('g').attr("transform", "translate(" + (margin.left) + ", " + 0 + ")")
	.append("svg").attr("id", "innersvg")
	.attr("width", width - (margin.left + margin.right)).attr("height", chart_h - margin.bottom);
	
var lowersvg = d3.select('#chart_lower').classed('chart_lower', true)
	.append("svg").attr("id", "lowersvg")
		.attr("width", width + margin.left + margin.right).attr("height", toggle3_h)
		.append("g")
		// transform the y coordinate by 5 to push buttons away from top edge of container
			.attr("transform", "translate(" + margin.left + ", " + 5 + ")");
	
	

// function to draw the horizontal gridlines
function make_gridline() {	 return d3.svg.axis().scale(y).orient("left").ticks(5);}


// called whenever mouse hovers over a data point
var tooltip = d3.select("body").append("div")   
	.attr("class", "tooltip")               
	.style("opacity", 0)
	.style("z-index", 999999);
		
// called whenever mouse hovers over a data point
var acutetooltip = d3.select("body").append("div")   
	.attr("class", "acutetooltip")               
	.style("opacity", 0)
	.style("z-index", 999999);
		
		
var datatip = d3.select("body").append("div")   
.attr("class", "datatip")               
.style("opacity", 0)
.style("z-index", 999999);


var datatiptable = function(d){
			
	var test = d.ACUTE > (d.CHRONIC * acuteloadupperthreshold) | d.ACUTE < (d.CHRONIC * acuteloadlowerthreshold);
	var sessiontimediffms = d.SESS_END - d.SESS_START;
	var sessionhours = ("0" + Math.floor((sessiontimediffms % 86400000) / 3600000)).slice(-2);
	var sessionmins = ("0" + Math.floor(((sessiontimediffms % 86400000) % 3600000) / 60000)).slice(-2);
	
	var pretimediffms = d.PRE_END - d.PRE_START;
	var prehours = ("0" + Math.floor((pretimediffms % 86400000) / 3600000)).slice(-2);
	var premins = ("0" + Math.floor(((pretimediffms % 86400000) % 3600000) / 60000)).slice(-2);
	
	var practtimediffms = d.PRACT_END - d.PRACT_START;
	var practhours = ("0" + Math.floor((practtimediffms % 86400000) / 3600000)).slice(-2);
	var practmins = ("0" + Math.floor(((practtimediffms % 86400000) % 3600000) / 60000)).slice(-2);
	
	var posttimediffms = d.POST_END - d.POST_START;
	var posthours = ("0" + Math.floor((posttimediffms % 86400000) / 3600000)).slice(-2);
	var postmins = ("0" + Math.floor(((posttimediffms % 86400000) % 3600000) / 60000)).slice(-2);
	
	var othertimediffms = d.OTHER_END - d.OTHER_START;
	var otherhours = ("0" + Math.floor((othertimediffms % 86400000) / 3600000)).slice(-2);
	var othermins = ("0" + Math.floor(((othertimediffms % 86400000) % 3600000) / 60000)).slice(-2);
	
	var header = "<table id='"+"datatiptable"+"'><tr><th>Data</th><th>Value</th><th>Duration</th></tr>";
	var topline = test ? "<tr><td>Acute Load</td><td class='cell'>"+ (parseInt(d.ACUTE))+" : "+ (Math.round((d.ACUTE/d.CHRONIC)*100)) +"%</td><td>.</td></tr>"
			: "<tr><td>Acute Load</td><td>"+ (parseInt(d.ACUTE))+" : "+ (Math.round((d.ACUTE/d.CHRONIC)*100)) +"%</td><td>.</td></tr>"
	var text = header.concat(topline);
	text = text.concat(
	"<tr><td>Chronic Load</td><td>"+ (parseInt(d.CHRONIC)) +"</td><td>.</td></tr>" +
	"<tr><td>Session Load </td><td>"+ (parseInt(d.SESS_LOAD)) +"</td><td>"+ sessionhours +":"+ sessionmins +"</td></tr>" +
	"<tr><td>Pre Load</td><td>"+ (parseInt(d.PRE_LOAD)) +"</td><td>"+ prehours +":"+ premins +"</td></tr>" +
	"<tr><td>Practice Load</td><td>"+ (parseInt(d.PRACT_LOAD)) +"</td><td>"+ practhours +":"+ practmins +"</td></tr>" +
	"<tr><td>Post Load</td><td>"+ (parseInt(d.POST_LOAD)) +"</td><td>"+ posthours +":"+ postmins +"</td></tr>" +
	"<tr><td>Other Load</td><td>"+ (parseInt(d.OTHER_LOAD)) +"</td><td>"+ otherhours +":"+ othermins +"</td></tr>" +
	"<tr><td>Notes</td><td><a title='this shows the full notes' href='#' onclick='moreNotes(); return false;'>"+ "click for notes" +"</a></td></tr>" +
	"</table>");
  		return text;
}

var moreNotes = function(d){
			
	    		datatip.transition()
				.duration(100)
				.style("opacity", 0.9)
				.style("color", "#2F4F4F")
				.style("border-color", "#667788");
	    		
	    		// here we test if there are new notes available for this player
	    		if(@player.playernumber > 5) {
	    		datatip .html("<table id='"+"notestiptable"+"'><tr><th>Date</th><th>Notes taken</th></tr>"
	    				+ "<tr><td>most recent</td><td>the note</td></tr>"
	    				
	    				+ "<tr><td>second most recent</td><td>the note</td></tr>"
	    				+ "<tr><td>etc..</td><td>etc...</td></tr></table>"
	    				
	    		
	    		)
	    		} else {
	    			datatip .html("<table id='"+"notestiptable"+"'><tr><th>Date</th><th>Notes taken</th></tr>"
		    				
		    				+ "<tr><td>etc..</td><td>etc...</td></tr></table>"
		    				
		    		
		    		)
	    		}
				//.style("left", (d3.event.pageX + 50) + "px")
				//.style("top", (d3.event.pageY -350) + "px")
				;
	    	
		}











// Get the players gps data
// read in the data
var dataset = d3.csv('@routes.Application.getCSV(player.playernumber)', function(error, data) {

	var calendar = d3.csv('@routes.Application.getCalendarCSV()', function(error2, data2) {
	
	var today = new Date();
	var threeweeksago = new Date(Date.now() + -21*24*3600*1000);
	var oneweekahead = new Date(Date.now() + 7*24*3600*1000);
	
	
		data.today = today;
		data.threeweeksago = threeweeksago;
		data.oneweekahead = oneweekahead;
		console.log("today is " + data.today);
		console.log("3 weeks ago is " + data.threeweeksago);
		console.log("1 week ahead is " + data.oneweekahead);
	
		data.forEach(function(d) {

		d.date = new Date((+d.SESS_START)*1000);
		d.SESS_LOAD = (+d.SESS_LOAD);
		d.SESS_START = new Date((+d.SESS_START)*1000);
		d.SESS_END = new Date((+d.SESS_END)*1000);
		
		d.PRE_LOAD = (+d.PRE_LOAD);
		d.PRE_START = new Date((+d.PRE_START)*1000);
		d.PRE_END = new Date((+d.PRE_END)*1000);
		
		d.PRACT_LOAD = (+d.PRACT_LOAD);
		d.PRACT_START = new Date((+d.PRACT_START)*1000);
		d.PRACT_END = new Date((+d.PRACT_END)*1000);
		
		d.POST_LOAD = (+d.POST_LOAD);
		d.POST_START = new Date((+d.POST_START)*1000);
		d.POST_END = new Date((+d.POST_END)*1000);
		
		d.ACUTE = (+d.ACUTE);
		d.CHRONIC = (+d.CHRONIC);
	});
	
		data2.forEach(function(d) {

		d.GAME_START = new Date((+d.GAME_START)*1000);
		d.GAME_END = new Date((+d.GAME_END)*1000);
		
		d.OPPONENT = d.OPPONENT;
		d.LOCATION = d.LOCATION;
		//console.log("today is " + today);
		//console.log("got " + d.GAME_START +" - " + d.GAME_END +" - " + d.OPPONENT +" - " + d.LOCATION);
		
	});
	
// everything must be inside these brackets

	// by default on start up - showing last 21 days of data and next 7 days of data
	var dayspast = data[0].SESS_START;
	//xScale.domain([data[0].SESS_START, data[data.length -1].SESS_END ]);
	               
    //xScale.domain([data2[0].GAME_START,  data2[data2.length -1].GAME_START  ]);
    //var threeweeksago = new Date(Date.now() + -21*24*3600*1000);
	//var oneweekahead = new Date(Date.now() + 7*24*3600*1000);
    
    xScale.domain([threeweeksago,  oneweekahead]);

	y.domain([0, 12]);
	y1.domain([1200, 0]);
	y2.domain([0,1200]);
	
	var zoom = d3.behavior.zoom()
	.x(xScale)
	.on('zoom', function() {
		
// 		var minN = d3.min(data, function (d) { return d.SESS_START; }).getTime(),
// 			maxN = d3.max(data, function (d) { return d.SESS_END; }).getTime();
		
// 	    if (xScale.domain()[0] < new Date(minN - 8.64e7)) {
// 	    	console.log("less than" + data[0].date);
// 	    	var x = zoom.translate()[0] - xScale(new Date(minN - 8.64e7)) + xScale.range()[0];
// 	        zoom.translate([x, 0]);
// 	    } else if (xScale.domain()[1] > new Date(maxN)) {
// 	    	console.log("more than" + data[1]);
// 	    	var x = zoom.translate()[0] - xScale(new Date(maxN)) + xScale.range()[1];
// 	        zoom.translate([x, 0]);
// 	    }
	    re_draw_chart();
	});
	
	
	
		// add a rectangle over the chart for zooming    
	innersvg.append('rect').attr("id", "zoomrect").attr("y", 0).attr('width', width).attr('height', chart_h)
		.attr("opacity", 0) .call(zoom);
	
	// add the x axis
	svg.append("g").attr("class", "x axis").attr("id", "xaxis")
		.attr("transform", "translate(0," + (chart_h - margin.bottom) + ")").call(xAxis);
	
	
	draw_chart();
	
	function draw_chart() {
	
		innersvg.selectAll(".now").data(data).enter().append("path")
		.attr("class", "now").attr("id", "now")
		.attr("stroke-width", 1)
		.style("stroke", "black")
		.style("fill", "black")
		.style("opacity", 0.2)

		.attr("d", d3.svg.symbol().type("triangle-up").size(50))
		// offset up by 5 if exceeding threshold, down by 5 otherwise
		.attr("transform", function(d) { 
			return "translate(" + xScale(data.today) + "," + (chart_h - margin.bottom - 10) + ")" });
	
	
	innersvg.selectAll('today').data(data).enter().append('rect')
		.attr("id", "todaymarker").attr("opacity", 1.0)
		.style("stroke", "black")
		.style("stroke-dasharray", "10,5")
		.style("fill", "none")
		.attr("x", function(d) {	return xScale(data.today);})
		.attr("y", function(d){		return 50;})
		.attr("width", function(d){	return 1;})
		.attr("height", function(d){return 400;});
		
	
	
	
			// the game rects
		innersvg.selectAll('gamerectangles').data(data2).enter().append("rect")
		.attr("id", "game").attr("opacity", 1.0)
		.style("stroke", "green")
		.style("fill", function(d) {
			return d.GAME_START > today ? "none" : "green";
		})
		.attr("x", function(d) {	return xScale(d.GAME_START);})
		.attr("y", function(d){		return 50;})
		.attr("width", function(d){	return (xScale(d.GAME_END) - xScale(d.GAME_START));})
		.attr("height", function(d){return 400;})
		.on("mouseover", function(d) {
			tooltip.transition()
				.duration(200)
				.style("opacity", 0.9).style("color", "blue").style("background", "rgba(0,128,128, 0.1)").style("border-color", "green");
			tooltip .html("Opponent : " + (d.OPPONENT) +"<br><br>" 
						+ "Location : " + (d.LOCATION) +"<br><br>" )
				.style("left", (d3.event.pageX + 20) + "px").style("top", (d3.event.pageY -150) + "px");})
		.on("mouseout", function(d) {       
			tooltip.transition()        
                .duration(500)      
                .style("opacity", 0);
		});
		
		// the chronic load shaded area
		innersvg.append("path").attr("class", "area").attr("id", "ChronicLoad")
 		.attr("stroke-width", 1).attr("stroke", "lightblue")
		.style("fill", "#AFDFF3").style("fill-opacity",0.3)
		.attr("d", chronicloadarea(data));

		
		// the pre practice rects
		innersvg.selectAll('prepracticerectangles').data(data).enter().append("rect")
		.attr("id", "prepracticeload").attr("opacity", 0.4)
		.style("stroke", sessionloads_chart_colour).style("fill", sessionloads_chart_colour)
		.attr("x", function(d) {	return xScale(d.PRE_START);})
		.attr("y", function(d){		return chart_h - margin.bottom - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.PRE_END) - xScale(d.PRE_START));})
		.attr("height", function(d){return y1(d.PRE_LOAD);});
		
		
		// the practice rects
		innersvg.selectAll('practicerectangles').data(data).enter().append("rect")
		.attr("id", "practiceload").attr("opacity", 1.0)
		.style("stroke", sessionloads_chart_colour).style("fill", sessionloads_chart_colour)
		.attr("x", function(d) {	return xScale(d.PRACT_START);})
		.attr("y", function(d){		return chart_h - margin.bottom - y1(d.PRACT_LOAD) - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.PRACT_END) - xScale(d.PRACT_START));})
		.attr("height", function(d){return y1(d.PRACT_LOAD);});
		
		
		// the post practice rects
		innersvg.selectAll('postpracticerectangles').data(data).enter().append("rect")
		.attr("id", "postpracticeload").attr("opacity", 0.4)
		.style("stroke", sessionloads_chart_colour).style("fill", sessionloads_chart_colour)
		.attr("x", function(d) {	return xScale(d.POST_START);})
		.attr("y", function(d){		return chart_h - margin.bottom -y1(d.POST_LOAD) - y1(d.PRACT_LOAD) - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.POST_END) - xScale(d.POST_START));})
		.attr("height", function(d){return y1(d.POST_LOAD);});
		
		
		// the session rects
		innersvg.selectAll('sessionrect').data(data).enter().append("rect")
		.attr("id", "sessionload").attr("opacity", 0.2)
		.style("stroke", sessionloads_chart_colour).style("fill", sessionloads_chart_colour)
		.attr("x", function(d) {	return xScale(d.SESS_START);})
		.attr("y", function(d){		return chart_h - margin.bottom - y1(d.SESS_LOAD);})
		.attr("width", function(d){	return (xScale(d.SESS_END) - xScale(d.SESS_START));})
		.attr("height", function(d){return y1(d.SESS_LOAD);})
		.on("mouseover", function(d) {
			tooltip.transition()
				.duration(200)
				.style("opacity", 0.9).style("color", "blue").style("background", "rgba(128,0,128, 0.1)").style("border-color", "purple");
			tooltip .html("Session Load........ " + (d.SESS_LOAD) +"<br><br>" 
						+ "Pre Practice Load... " + (d.PRE_LOAD) +"<br><br>"
						+ "Practice Load....... " + (d.PRACT_LOAD) +"<br><br>"
						+ "Post Practice Load.. " + (d.POST_LOAD) )
				.style("left", (d3.event.pageX + 20) + "px").style("top", (d3.event.pageY -150) + "px");})
		.on("mouseout", function(d) {       
			tooltip.transition()        
                .duration(500)      
                .style("opacity", 0);
		})
		.on("click", function(d) {
			// remove the tooltip
			tooltip.style("opacity", 0);
    		datatip.transition().duration(100)
			.style("opacity", 0.9).style("color", "#2F4F4F").style("border-color", "#778899");
    		datatip .html(datatiptable(d))
			.style("left", (d3.event.pageX) + "px").style("top", (d3.event.pageY -250) + "px");
		});
		
		// the acute load line
		innersvg.append("path")
		.attr("class", "line").attr("id", "ACLoad").attr("stroke-width", 1)
		.style("stroke", "red").style("fill", "none")
		.attr("d", acuteline(data));
		
		
		// adding the flags along the acute line
		innersvg.selectAll(".flag").data(data).enter().append("path")
		.attr("class", "flag").attr("id", "UPFlags").attr("stroke-width", 1)
		.style("stroke", "red").style("fill", "red").style("opacity", 0.2)
		// only apply the flags if the data point out of range
 		.filter(function(d){
 			return d.ACUTE > (d.CHRONIC * acuteloadupperthreshold) 
 				| d.ACUTE < (d.CHRONIC * acuteloadlowerthreshold) ? d.ACUTE : null;})
		.attr("d", d3.svg.symbol().type( function(d){
			// point the triangle up if exceeding the threshold, down otherwise
			return d.ACUTE > (d.CHRONIC * acuteloadupperthreshold) ? 	"triangle-up" : "triangle-down";	}).size(20))
		// offset up by 5 if exceeding threshold, down by 5 otherwise
		.attr("transform", function(d) { 
			return "translate(" + xScale(d.SESS_START) + "," + (y2(d.ACUTE) + (d.ACUTE > (d.CHRONIC * acuteloadupperthreshold) ? 5 : -5)) + ")" });
			
			
			
		// add sensor circles (dots) to the Acute Load line
	    innersvg.selectAll("dot").data(data).enter().append("circle")
  		.attr("id", "ACLoadDot").attr("r", 20)
    	.style("opacity", 0)
    	.attr("cx", function(d) { return xScale(d.SESS_START); })
    	.attr("cy", function(d) { return y2(d.ACUTE); })
    	.on("mouseover", function(d) {
    		acutetooltip.transition().duration(200)
				.style("opacity", 0.9).style("color", "red").style("background", "rgba(255,0,0, 0.1)").style("border-color", "red");
    		acutetooltip .html("Acute : " + (parseInt(d.ACUTE)))
				.style("left", (d3.event.pageX) + "px").style("top", (d3.event.pageY -50) + "px");
			})
		.on("mouseout", function(d) {       
			acutetooltip.transition().duration(500).style("opacity", 0);
		})
		.on("click", function(d) {
			// remove the tooltip
			acutetooltip.style("opacity", 0);
    		datatip.transition().duration(100)
			.style("opacity", 0.9).style("color", "#2F4F4F").style("border-color", "#778899");
    		datatip .html(datatiptable(d))
			.style("left", (d3.event.pageX) + "px").style("top", (d3.event.pageY -250) + "px");
		});
		
		
		
	} // end drawchart()
	
	
	
	function re_draw_chart() {
	
		datatip.transition().duration(200).style("opacity", 0);
		
		innersvg.selectAll("#now")
		.attr("transform", function(d) { 
			return "translate(" + xScale(data.today) + "," + (chart_h - margin.bottom - 10) + ")" });
		
		
		innersvg.selectAll('#todaymarker')
		.attr("x", function(d) {	return xScale(data.today);})
		.attr("y", function(d){		return 50;})
		.attr("width", function(d){	return 1;})
		.attr("height", function(d){return 400;});
		
		
		// the game rects
		innersvg.selectAll('#game')
		.attr("x", function(d) {	return xScale(d.GAME_START);})
		.attr("y", function(d){		return 50;})
		.attr("width", function(d){	return (xScale(d.GAME_END) - xScale(d.GAME_START));})
		.attr("height", function(d){return 400;});
		
		innersvg.selectAll("#ChronicLoad")
		.attr("d", chronicloadarea(data));
	
		
		innersvg.selectAll("#sessionload")
		.attr("x", function(d){	return xScale(d.SESS_START); })
		.attr("y", function(d){	return chart_h - margin.bottom - y1(d.SESS_LOAD); })
		.attr("width", function(d){	return (xScale(d.SESS_END) - xScale(d.SESS_START));})
		.attr("height", function(d){return y1(d.SESS_LOAD);
		});
		
		
		// the pre practice rects
		innersvg.selectAll('#prepracticeload')
		.attr("x", function(d) {	return xScale(d.PRE_START);})
		.attr("y", function(d){		return chart_h - margin.bottom - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.PRE_END) - xScale(d.PRE_START));})
		.attr("height", function(d){return y1(d.PRE_LOAD);});
		
		
		// the practice rects
		innersvg.selectAll('#practiceload')
		.attr("x", function(d) {	return xScale(d.PRACT_START);})
		.attr("y", function(d){		return chart_h - margin.bottom - y1(d.PRACT_LOAD) - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.PRACT_END) - xScale(d.PRACT_START));})
		.attr("height", function(d){return y1(d.PRACT_LOAD);});
		
		
		// the post practice rects
		innersvg.selectAll('#postpracticeload')
		.attr("x", function(d) {	return xScale(d.POST_START);})
		.attr("y", function(d){		return chart_h - margin.bottom -y1(d.POST_LOAD) - y1(d.PRACT_LOAD) - y1(d.PRE_LOAD);})
		.attr("width", function(d){	return (xScale(d.POST_END) - xScale(d.POST_START));})
		.attr("height", function(d){return y1(d.POST_LOAD);	});
		
		// the acute load line
		innersvg.selectAll("#ACLoad").attr("d", acuteline(data));
		
		// the acute load line sensors for the tooltips
		innersvg.selectAll("#ACLoadDot")
    	.attr("cx", function(d) { return xScale(d.SESS_START); })
    	.attr("cy", function(d) { return y2(d.ACUTE); });
		
		// the alert flags along the acute load line
		innersvg.selectAll("#UPFlags")
		.attr("transform", function(d) { return "translate(" + xScale(d.SESS_START) + "," + (y2(d.ACUTE) + (d.ACUTE > (d.CHRONIC * 1.5) ? 5 : -5)) + ")" });
		
		svg.selectAll("#xaxis").call(xAxis);
		
	}
	
	   
    // add the y axis
	innersvg.append("g").attr("class", "y axis").call(yAxis)
		// push the y-axis to the right by 5px and upwards off the gridline by 6px
		.attr("transform", "translate(" + 5 + ", -" + 6 + ")");
    
    // horizontal gridlines
	innersvg.append("g").attr("class", "grid").call(make_gridline().tickSize(-width, 0, 0) .tickFormat(""))
	    
	    
	    		// function that draws middle(above chart) box buttons
function drawAuxButton(buttontext, buttonid, bordercolor, lineid, i, toggled){
			
			var numButtonsToggle2 = 11;
			var buttonOffset = width/(numButtons + 1);

			var abutton;
			if(width < 1000){
				//console.log("i is "+i);
				var dx = i<5 ? (width/((numButtonsToggle2/2) + 1)) * (i % 5) : (width/((numButtonsToggle2/2) + 1)) * ((i % 5) + 1);
				var dy = i>4 ? 50 : 0;
				abutton = uppersvg.append("g")
				.attr("transform", "translate("+ dx + "," + dy + ")");
			} else {
				abutton = uppersvg.append("g")
				.attr("transform", "translate("+ (i * (width/(numButtonsToggle2 + 1))) + "," + 0 + ")");
			}
			
			
			abutton.append("text").attr("x", 10).attr("y", 15).attr("fill", bordercolor).text(buttontext);
	        
			// get the width of the text and use it to tailor the width of the rect around it
 			var textWidth = abutton.select("text").node().getBBox().width;
			
			abutton.append("rect")
			.attr("rx", 0)
		    .attr("ry", 10)
		    .attr("width", textWidth + 20)
	 	    .attr("height", 20)
		    .attr("class", "legend")
		    .attr("id", buttonid) 
		    .attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.1)")
		    .style("stroke-width", toggled ? 0 : 0)
		    .style("stroke", toggled ? bordercolor : "grey")
		    .style("opacity", function(d) {
		    	this.active = toggled;
		     	})
		    
		    
		    .on("click", function(){
		    	
		    	var isActive;
		        // Hide or show the line
		        d3.select("#"+lineid).style("opacity", function(d) {
		        	// Toggle the active state
		        	this.active = !this.active;	isActive = this.active; return	this.active ? 1 : 0; })
		        
		        // update the buttons border
		        d3.select("#"+buttonid)
		        .style("stroke", isActive ? bordercolor : "grey").style("stroke-width", isActive ? 2 : 0)});
			
		} // end drawAuxButton
		
		drawAuxButton("GPS DATA", "Catapult_Button", "black", "", 0, true);
		drawAuxButton("REDOX", "Optojump_Button", "black", "", 1, true);
		drawAuxButton("CALENDAR", "Biomarkers_Button", "black", "", 2, true);
		
		
		
var numButtons = 7;
		
		function drawButton(buttontext, buttonid, bordercolor, lineid, dotid, i, toggled){
			
			// turns the line associated with this button on or off according to toggled parameter
			d3.select("#"+lineid)
        	.style("opacity", function(d) { 
        		this.active = toggled;
        		return toggled ? 1 : 0;
        	})
        	
        	d3.select("#"+dotid)
        	.style("opacity", function(d) { 
        		this.active = toggled;
        		return toggled ? 1 : 0;
        	})

			var abutton;
			if(width < 1000){
				console.log("i is "+i);
				var dx = i<5 ? (width/((numButtons/2) + 1)) * (i % 5) : (width/((numButtons/2) + 1)) * ((i % 5) + 1);
				var dy = i>4 ? 50 : 0;
				abutton = lowersvg.append("g")
				.attr("transform", "translate("+ dx + "," + dy + ")");
			} else {
				abutton = lowersvg.append("g")
				.attr("transform", "translate("+ (i * (width/(numButtons + 1))) + "," + 0 + ")");
			}
			
			
			abutton.append("text")
			.attr("x", 10)             
		    .attr("y", 15)
		    .attr("fill", bordercolor)
	        .text(buttontext);
	        
			// get the width of the text and use it to tailor the width of the rect around it
 			var textWidth = abutton.select("text").node().getBBox().width;
			
			abutton.append("rect")
		    .attr("rx", 0)
		    .attr("ry", 10)
		    .attr("width", textWidth + 20)
	 	    .attr("height", 20)
		    .attr("class", "legend")
		    .attr("id", buttonid) 
		    .attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.1)")
		    .style("stroke-width", toggled ? 2 : 0)
		    .style("stroke", toggled ? bordercolor : "grey")
		    .style("opacity", function(d) {
		    	this.active = toggled;
		     	//console.log(this.active);
		     	})
		    
		    
		    .on("click", function(){
		    	
		    	var isActive;
		        // Hide or show the line
		        d3.select("#"+lineid)
		        	.style("opacity", function(d) {
		        	// Toggle the active state
		        	//console.log(this.active);
		        	this.active = !this.active;
		        	isActive = this.active;
			        return	this.active ? 1 : 0;
		        });
		        
		        // enable/disable the tooltips for this buttons dots
		        d3.selectAll("#"+dotid)
		        	.on("mouseover", function(d) {
		        		return isActive ? 
		        				d3.event.stopPropagation() : null; // TODO: rework this such that it re-enables the tooltips
		        	});
		        	
		        // update the buttons border
		        d3.select("#"+buttonid)
		        .style("stroke", isActive ? bordercolor : "grey")
		        .style("stroke-width", isActive ? 2 : 0)
		    	});
			
		} // end drawButton
		
//special function to draw and control button for acute chronic load
function drawACButton(lineid1, lineid2, flagid, i, toggled){
			
			// turns the line associated with this button on or off according to toggled parameter
			d3.select("#"+lineid1)
        		.style("opacity", function(d) { this.active = toggled;	return toggled ? 1 : 0;})
        		
        	d3.select("#"+lineid2)
        		.style("opacity", function(d) { this.active = toggled;	return toggled ? 1 : 0;})
	        	
	        d3.selectAll("#"+flagid)
	        	.style("opacity", function(d) { this.active = toggled;	return toggled ? 1 : 0;})
	        	
			var abutton;
			if(width < 1000){
				var dx = i<5 ? (width/((numButtons/2) + 1)) * (i % 5) : (width/((numButtons/2) + 1)) * ((i % 5) + 1);
				var dy = i>4 ? 50 : 0;
				abutton = lowersvg.append("g").attr("transform", "translate("+ dx + "," + dy + ")");
			} else {
				abutton = lowersvg.append("g").attr("transform", "translate("+ (i * (width/(numButtons + 1))) + "," + 0 + ")");
			}
			
			abutton.append("text").attr("x", 10).attr("y", 15).attr("fill", acutechronic_button_border_colour).text(acutechronic_button_text);
	        
			// get the width of the text and use it to tailor the width of the rect around it
 			var textWidth = abutton.select("text").node().getBBox().width;
			
			abutton.append("rect").attr("rx", 0).attr("ry", 10)
		    .attr("width", textWidth + 20).attr("height", 20)
		    .attr("class", "legend").attr("id", "ACLoad_Button") 
		    .attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.1)").style("stroke-width", toggled ? 2 : 0)
		    .style("stroke", toggled ? acutechronic_button_border_colour : "grey").style("opacity", function(d) { this.active = toggled;})
		    .on("click", function(){
		    	
		    	var isActive;
		        // Hide or show the line
		        d3.select("#"+lineid1).style("opacity", function(d) { 
		        	this.active = !this.active; isActive = this.active; return	this.active ? 1 : 0; })
		        
		       	d3.select("#"+lineid2).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active;	return	this.active ? 1 : 0;})
		        
		        d3.selectAll("#"+flagid).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active; return	this.active ? 1 : 0;})
		        
		        // update the buttons border
		        d3.select("#ACLoad_Button")
		        	.style("stroke", isActive ? acutechronic_button_border_colour : "grey").style("stroke-width", isActive ? 2 : 0)});
			
		} // end drawACButton
		
		
		
//special function to draw and control button for session loads
function drawSESSButton(rectid1, rectid2, rectid3, rectid4, i, toggled){

			// turns the line associated with this button on or off according to toggled parameter
			d3.selectAll("#"+rectid1).style("opacity", function(d) { 
	        		this.active = toggled;	return toggled ? 0.2 : 0;})
        		
        	d3.selectAll("#"+rectid2).style("opacity", function(d) { 
	        		this.active = toggled;	return toggled ? 0.4 : 0;})
	        	
	        d3.selectAll("#"+rectid3).style("opacity", function(d) { 
	        		this.active = toggled;	return toggled ? 1 : 0;})
	        	
	        d3.selectAll("#"+rectid4).style("opacity", function(d) { 
	        		this.active = toggled;	return toggled ? 0.4 : 0;})
	        	
			var abutton;
			if(width < 1000){
				var dx = i<5 ? (width/((numButtons/2) + 1)) * (i % 5) : (width/((numButtons/2) + 1)) * ((i % 5) + 1);
				var dy = i>4 ? 50 : 0;
				abutton = lowersvg.append("g").attr("transform", "translate("+ dx + "," + dy + ")");
			} else {
				abutton = lowersvg.append("g").attr("transform", "translate("+ (i * (width/(numButtons + 1))) + "," + 0 + ")");
			}
	        	
			
			abutton.append("text").attr("x", 10).attr("y", 15).attr("fill", sessionloads_button_border_colour).text(sessionloads_button_text);
	        
			// get the width of the text and use it to tailor the width of the rect around it
 			var textWidth = abutton.select("text").node().getBBox().width;
			abutton.append("rect").attr("rx", 0).attr("ry", 10)
		    .attr("width", textWidth + 20).attr("height", 20)
		    .attr("class", "legend").attr("id", "Session_Load_Button").attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.1)").style("stroke-width", toggled ? 2 : 0)
		    .style("stroke", toggled ? sessionloads_button_border_colour : "grey")
		    .style("opacity", function(d) {	this.active = toggled;})
		    .on("click", function(){
		    	var isActive;
		        // Hide or show the line
		        d3.selectAll("#"+rectid1).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active;	return	this.active ? 0.2 : 0;})
		        
		       	d3.selectAll("#"+rectid2).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active;	return	this.active ? 0.4 : 0;})
		        
		        d3.selectAll("#"+rectid3).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active;	return	this.active ? 1 : 0; })
		        
		        d3.selectAll("#"+rectid4).style("opacity", function(d) {
		        	this.active = !this.active;	isActive = this.active;	return	this.active ? 0.4 : 0; })
		        
		        // update the buttons border
		        d3.select("#Session_Load_Button")
		        	.style("stroke", isActive ? sessionloads_button_border_colour : "grey").style("stroke-width", isActive ? 2 : 0)});
			
		} // end drawSESSButton
		
		
		
			var drawButtons = function(){
			
			// first remove all elements from this svg container
			lowersvg.selectAll("g").remove();
			// combined a/c load button
			drawACButton("ACLoad", "ChronicLoad", "UPFlags", 1, true);
			
			// player session loads
			drawSESSButton("sessionload", "postpracticeload", "practiceload", "prepracticeload", 2, true);
			
			//acc/dec load button 	
			drawButton("ACC/DEC", "ACCDEC_Button", "blue", "ACCDECLoad", "ACCDECLoadDot", 3, false);
				
			// rpe score button
			drawButton("RPE SCORES", "RPE_Button", "black", "RPEScore", null, 4, false);
				
			// sleep button
			drawButton("SLEEP", "Sleep_Button", "steelblue", "Sleep", null, 5, false);
			
			// muscle soreness
			drawButton("MUS SOR", "MuscleSoreness_Button", "green", "muscleSoreness", null, 6, false);
			
			// heart rate
			drawButton("HR", "HR_Button", "orange", "heartrate", null, 7, false);
		}
		
		drawButtons();

	
	// handling window resizing
	d3.select(window).on('resize', resize);
	
	function resize() {
	    // update width
	    width = parseInt(d3.select('#chart_centre').style('width'), 10);
	    xScale.range([0, width]);
	    buttonOffset = width/(numButtons + 1);
	    drawButtons();
	    re_draw_chart();
	}



});
	


	

	
	

	
	});

</script>


}


